// FILE: package.json
{
  "name": "softair-store",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "eslint --ext .ts,.tsx src",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,json,md}\"",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "e2e": "playwright test",
    "prisma:migrate": "prisma migrate dev --name init",
    "prisma:generate": "prisma generate",
    "seed": "ts-node --transpile-only prisma/seed.ts",
    "docker:dev": "docker-compose -f docker-compose.yml up --build"
  },
  "dependencies": {
    "next": "13.4.6",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "5.3.3",
    "@prisma/client": "5.2.0",
    "bcrypt": "5.1.0",
    "jsonwebtoken": "9.0.0",
    "zod": "4.25.0",
    "stripe": "12.8.0",
    "nodemailer": "6.9.4",
    "axios": "1.4.0",
    "cookie": "0.6.0",
    "cors": "2.8.5",
    "helmet": "7.0.0",
    "express-rate-limit": "6.7.0",
    "pg": "8.11.0",
    "swr": "2.3.0",
    "clsx": "2.1.1",
    "@heroicons/react": "2.0.18",
    "tailwindcss": "3.4.7",
    "autoprefixer": "10.4.14",
    "postcss": "8.4.26"
  },
  "devDependencies": {
    "@types/node": "20.3.1",
    "@types/react": "18.2.21",
    "@types/jsonwebtoken": "9.0.2",
    "prisma": "5.2.0",
    "eslint": "8.45.0",
    "eslint-config-next": "13.4.6",
    "prettier": "3.0.0",
    "husky": "8.0.3",
    "lint-staged": "14.3.0",
    "jest": "29.6.0",
    "ts-jest": "29.1.0",
    "@testing-library/react": "14.0.0",
    "playwright": "1.44.0",
    "ts-node": "10.9.1"
  }
}

// FILE: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

// FILE: next.config.js
/**
 * Next.js configuration
 * - Abilita i domini delle immagini (sostituire con domini reali in prod)
 * - Config per Internationalized Routing (i18n)
 */
module.exports = {
  reactStrictMode: true,
  images: {
    domains: ["localhost", "res.cloudinary.com"],
  },
  i18n: {
    locales: ["it", "en"],
    defaultLocale: "it",
  },
  experimental: {
    serverActions: true
  }
};

// FILE: .env.example
# Server
NEXT_PUBLIC_APP_URL=http://localhost:3000
APP_HOST=0.0.0.0
PORT=3000

# Database
DATABASE_URL=postgresql://postgres:password@db:5432/softair?schema=public

# JWT
JWT_ACCESS_TOKEN_SECRET=change_this_access_secret
JWT_REFRESH_TOKEN_SECRET=change_this_refresh_secret
ACCESS_TOKEN_EXP=15m
REFRESH_TOKEN_EXP=30d

# Stripe (test)
STRIPE_API_KEY=sk_test_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx
STRIPE_PRICE_ID_SAMPLE=price_xxx

# Email (SMTP)
SMTP_HOST=smtp.mailtrap.io
SMTP_PORT=2525
SMTP_USER=your_user
SMTP_PASS=your_pass
EMAIL_FROM=Softair Store <noreply@softairstore.test>

# Prisma
SHADOW_DATABASE_URL=postgresql://postgres:password@db:5432/softair_shadow

# App
NODE_ENV=development
NEXT_PUBLIC_DEFAULT_LOCALE=it

# GDPR
COOKIE_CONSENT_REQUIRED=true

# Dev keys
ADMIN_EMAIL=admin@softair.test

// FILE: Dockerfile
# Dockerfile per produzione (multistage)
FROM node:20-alpine AS builder
WORKDIR /app

# install dependencies
COPY package.json yarn.lock* package-lock.json* ./
RUN npm ci --production=false

# build
COPY . .
RUN npm run build
RUN npm prune --production

# runtime
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

COPY --from=builder /app/package.json .
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/prisma ./prisma

EXPOSE 3000
CMD ["npm","start"]

// FILE: docker-compose.yml
version: '3.8'
services:
  db:
    image: postgres:15
    restart: unless-stopped
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: softair
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - '5432:5432'

  adminer:
    image: adminer
    restart: unless-stopped
    ports:
      - '8080:8080'

  web:
    build: .
    command: npm run dev
    volumes:
      - ./:/app
      - /app/node_modules
    ports:
      - '3000:3000'
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/softair
      - NEXT_PUBLIC_APP_URL=http://localhost:3000
    depends_on:
      - db

volumes:
  db-data:

// FILE: prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?
  passwordHash   String
  role           UserRole @default(USER)
  verified       Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  orders         Order[]
  reviews        Review[]
  refreshTokens  RefreshToken[]
}

enum UserRole {
  USER
  ADMIN
}

model RefreshToken {
  id         String   @id @default(cuid())
  token      String   @unique
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
}

model Product {
  id          String     @id @default(cuid())
  sku         String     @unique
  name        String
  description String
  brand       String?
  category    String?
  priceCents  Int
  stock       Int        @default(0)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  images      ProductImage[]
  variants    ProductVariant[]
  reviews     Review[]
}

model ProductImage {
  id        String  @id @default(cuid())
  url       String
  alt       String?
  product   Product @relation(fields: [productId], references: [id])
  productId String
}

model ProductVariant {
  id        String  @id @default(cuid())
  product   Product @relation(fields: [productId], references: [id])
  productId String
  name      String  // e.g. color/size/potenza
  value     String
  extraPrice Int    @default(0)
  stock     Int     @default(0)
}

model Order {
  id          String    @id @default(cuid())
  user        User?     @relation(fields: [userId], references: [id])
  userId      String?
  totalCents  Int
  status      OrderStatus @default(PENDING)
  shipping    String?
  createdAt   DateTime   @default(now())
  items       OrderItem[]
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}

model OrderItem {
  id         String   @id @default(cuid())
  order      Order    @relation(fields: [orderId], references: [id])
  orderId    String
  product    Product  @relation(fields: [productId], references: [id])
  productId  String
  variantId  String?
  quantity   Int
  unitCents  Int
}

model Review {
  id         String  @id @default(cuid())
  product    Product @relation(fields: [productId], references: [id])
  productId  String
  user       User?   @relation(fields: [userId], references: [id])
  userId     String?
  rating     Int
  title      String?
  body       String?
  moderated  Boolean @default(false)
  createdAt  DateTime @default(now())
}

model Coupon {
  id         String  @id @default(cuid())
  code       String  @unique
  discountPct Int
  expiresAt  DateTime?
  active     Boolean @default(true)
}

// FILE: src/lib/prisma.ts
// prisma client singleton per evitare connessioni multiple in dev (hot reload)
import { PrismaClient } from '@prisma/client'

declare global {
  // eslint-disable-next-line no-var
  var prisma: PrismaClient | undefined
}

export const prisma = global.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== 'production') global.prisma = prisma

// FILE: src/lib/jwt.ts
// helper per generare e verificare access/refresh JWT
import jwt from 'jsonwebtoken'

const ACCESS_SECRET = process.env.JWT_ACCESS_TOKEN_SECRET || 'dev_access_secret'
const REFRESH_SECRET = process.env.JWT_REFRESH_TOKEN_SECRET || 'dev_refresh_secret'

export function signAccessToken(payload: object) {
  return jwt.sign(payload, ACCESS_SECRET, { expiresIn: process.env.ACCESS_TOKEN_EXP || '15m' })
}

export function signRefreshToken(payload: object) {
  return jwt.sign(payload, REFRESH_SECRET, { expiresIn: process.env.REFRESH_TOKEN_EXP || '30d' })
}

export function verifyAccessToken(token: string) {
  return jwt.verify(token, ACCESS_SECRET)
}

export function verifyRefreshToken(token: string) {
  return jwt.verify(token, REFRESH_SECRET)
}

// FILE: src/lib/stripe.ts
// Stripe helper (modalità test)
import Stripe from 'stripe'

const stripeKey = process.env.STRIPE_API_KEY || ''
export const stripe = new Stripe(stripeKey, { apiVersion: '2024-11-14' })

// Funzione di esempio: crea sessione checkout
export async function createCheckoutSession({ line_items, success_url, cancel_url }: any) {
  return stripe.checkout.sessions.create({
    line_items,
    mode: 'payment',
    success_url,
    cancel_url
  })
}

// FILE: src/lib/email.ts
// Semplice wrapper nodemailer per invio email (verifica, ordini)
import nodemailer from 'nodemailer'

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT || 587),
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
})

export async function sendVerificationEmail(email: string, payload: any) {
  const verifyUrl = `${process.env.NEXT_PUBLIC_APP_URL}/verify-email?token=TODO` // generare token di verifica
  await transporter.sendMail({
    from: process.env.EMAIL_FROM,
    to: email,
    subject: 'Verifica la tua email',
    text: `Clicca qui per verificare: ${verifyUrl}`,
    html: `<p>Clicca <a href="${verifyUrl}">qui</a> per verificare la tua email.</p>`
  })
}

// FILE: src/pages/_app.tsx
// App wrapper: Tailwind, i18n (semplice), provider per auth/swr
import '../styles/globals.css'
import type { AppProps } from 'next/app'
import { SWRConfig } from 'swr'
import axios from 'axios'

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <SWRConfig value={{ fetcher: (url: string) => axios.get(url).then(r => r.data) }}>
      <Component {...pageProps} />
    </SWRConfig>
  )
}

export default MyApp

// FILE: src/pages/index.tsx
import type { NextPage } from 'next'
import Link from 'next/link'

const Home: NextPage = () => {
  return (
    <main className="min-h-screen p-8">
      <h1 className="text-3xl font-bold">Softair Store</h1>
      <p className="mt-4">Benvenuto! Negozio demo per attrezzatura softair.</p>
      <Link href="/products" className="mt-6 inline-block underline">Vai al catalogo</Link>
    </main>
  )
}

export default Home

// FILE: src/pages/api/auth/register.ts
// Route API Next.js: registrazione utente
import type { NextApiRequest, NextApiResponse } from 'next'
import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import bcrypt from 'bcrypt'
import { signRefreshToken, signAccessToken } from '@/lib/jwt'
import { sendVerificationEmail } from '@/lib/email'

const bodySchema = z.object({ email: z.string().email(), password: z.string().min(8), name: z.string().optional() })

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).end()
  const parse = bodySchema.safeParse(req.body)
  if (!parse.success) return res.status(400).json({ error: parse.error.errors })

  const { email, password, name } = parse.data

  const existing = await prisma.user.findUnique({ where: { email } })
  if (existing) return res.status(409).json({ error: 'Utente già registrato' })

  const passwordHash = await bcrypt.hash(password, 10)
  const user = await prisma.user.create({ data: { email, passwordHash, name } })

  // creare refresh token in DB
  const refreshToken = signRefreshToken({ userId: user.id })
  await prisma.refreshToken.create({ data: { token: refreshToken, userId: user.id, expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30) } })

  const accessToken = signAccessToken({ userId: user.id, role: user.role })

  // invia email di verifica (async, non bloccare in produzione con retry)
  sendVerificationEmail(user.email, { userId: user.id })

  res.status(201).json({ user: { id: user.id, email: user.email, name: user.name }, accessToken, refreshToken })
}

// FILE: src/pages/api/auth/login.ts
// Login: restituisce access + refresh token
import type { NextApiRequest, NextApiResponse } from 'next'
import { prisma } from '@/lib/prisma'
import bcrypt from 'bcrypt'
import { signAccessToken, signRefreshToken } from '@/lib/jwt'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).end()
  const { email, password } = req.body
  const user = await prisma.user.findUnique({ where: { email } })
  if (!user) return res.status(401).json({ error: 'Credenziali non valide' })

  const ok = await bcrypt.compare(password, user.passwordHash)
  if (!ok) return res.status(401).json({ error: 'Credenziali non valide' })

  const accessToken = signAccessToken({ userId: user.id, role: user.role })
  const refreshToken = signRefreshToken({ userId: user.id })

  await prisma.refreshToken.create({ data: { token: refreshToken, userId: user.id, expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30) } })

  res.json({ accessToken, refreshToken, user: { id: user.id, email: user.email, name: user.name } })
}

// FILE: src/pages/api/products/index.ts
// Lista prodotti con filtri e paginazione base (es. ?q=bersaglio&minPrice=1000&brand=XYZ)
import type { NextApiRequest, NextApiResponse } from 'next'
import { prisma } from '@/lib/prisma'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') return res.status(405).end()

  const { q, brand, minPrice, maxPrice, page = '1', perPage = '12' } = req.query
  const where: any = {}
  if (q) {
    // semplice ricerca: name contains. In prod: usare full-text o Elastic.
    where.OR = [
      { name: { contains: String(q), mode: 'insensitive' } },
      { description: { contains: String(q), mode: 'insensitive' } }
    ]
  }
  if (brand) where.brand = String(brand)
  if (minPrice || maxPrice) where.priceCents = {}
  if (minPrice) where.priceCents.gte = parseInt(String(minPrice))
  if (maxPrice) where.priceCents.lte = parseInt(String(maxPrice))

  const skip = (Number(page) - 1) * Number(perPage)
  const products = await prisma.product.findMany({ where, take: Number(perPage), skip, include: { images: true, variants: true } })
  const total = await prisma.product.count({ where })

  res.json({ data: products, meta: { total, page: Number(page), perPage: Number(perPage) } })
}

// FILE: src/middlewares/errorHandler.ts
// Middleware/error util per API Routes Next.js: centralizza risposta errori
export function handleError(res: any, error: any) {
  console.error(error)
  if (error?.code === 'P2002') return res.status(409).json({ error: 'Risorsa già esistente' })
  return res.status(500).json({ error: 'Errore interno' })
}

// FILE: jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: ['src/**/*.{ts,tsx}', '!src/**/*.d.ts', '!src/**/index.ts']
}

// FILE: README.md
# Softair Store

## Obiettivo
Repo starter per un ecommerce di softair, con stack Next.js + TypeScript + Prisma + PostgreSQL e integrazione Stripe.

## Setup locale
1. Copia `.env.example` in `.env` e popola i valori.
2. Avvia i servizi con Docker (opzionale): `docker-compose up --build`
3. Installa dipendenze: `npm ci`
4. Genera prisma client: `npm run prisma:generate`
5. Applica migrazioni: `npm run prisma:migrate`
6. Esegui seed: `npm run seed`
7. Avvia dev: `npm run dev`

## Stripe testing
- Imposta `STRIPE_API_KEY` con la chiave test (inizia con `sk_test_...`).
- Nella dashboard Stripe impostare prodotti/prices test o usare `STRIPE_PRICE_ID_SAMPLE`.
- Per webhook locali usare `stripe-cli` per forward/inspect.

## Tests
- Unit: `npm test`
- E2E: `npm run e2e`

## Deploy
- Utilizzare Docker image prod (vedi Dockerfile) su VPS/Render/Railway.
- Salvare segreti in provider e impostare DATABASE_URL.

// FILE: CHANGELOG.md
# Changelog

## [1.0.0] - 2025-09-20
- Primo rilascio del progetto base
- Implementate: autenticazione (JWT), schema Prisma, API prodotti, integrazione Stripe helper
- Dockerfile e docker-compose per dev
- Test scaffolding (Jest + Playwright)

// FILE: src/tests/unit/auth.spec.ts
import { describe, expect, it } from '@jest/globals'

describe('Auth service (esempio)', () => {
  it('esempio placeholder', async () => {
    expect(true).toBe(true)
  })
})

// FILE: AdditionalNotes.txt
/*
NOTE IMPORTANTI:
- Questo blocco include i file principali richiesti. Per completare il progetto in produzione:
  - Aggiungere file mancanti: ESLint config, Prettier config, .gitignore, Playwright config, Husky + lint-staged config, prisma/seed.ts.
  - Implementare pagine front-end complesse (catalogo, prodotto, carrello, checkout).
  - Aggiungere migrazioni SQL per indici full-text (tsvector) o integrare ElasticSearch per ricerca avanzata.
  - Implementare gestione refresh token sicura (HttpOnly cookies o storage protetto), revoca token, logout.
  - Configurare HTTPS/TLS nel deploy e usare secret manager per chiavi sensibili.
- STRIPE:
  - Mettere la chiave test in STRIPE_API_KEY (es. sk_test_...)
  - Per testare webhook in locale usare `stripe listen --forward-to localhost:3000/api/webhooks/stripe` e impostare STRIPE_WEBHOOK_SECRET
- Esecuzione test:
  - Unit tests: `npm test` (Jest)
  - E2E: `npx playwright install` poi `npm run e2e`
*/
